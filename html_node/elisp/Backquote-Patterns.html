<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rev="made" href="mailto:bug-gnu-emacs@gnu.org">
<link rel="icon" type="image/png" href="/graphics/gnu-head-mini.png">
<meta name="ICBM" content="42.256233,-71.006581">
<meta name="DC.title" content="gnu.org">

<title>Backquote Patterns - GNU Emacs Lisp Reference Manual</title>
<!--
This is the `GNU Emacs Lisp Reference Manual'
corresponding to Emacs version 26.2.

Copyright (C) 1990--1996, 1998--2019 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being ``GNU General Public
     License,'' with the Front-Cover Texts being ``A GNU Manual,'' and
     with the Back-Cover Texts as in (a) below.  A copy of the license
     is included in the section entitled ``GNU Free Documentation
     License.''

     (a) The FSF's Back-Cover Text is: ``You have the freedom to copy
     and modify this GNU manual.  Buying copies from the FSF supports
     it in developing GNU and promoting software freedom.''
   -->
<style type="text/css">
@import url('/software/emacs/manual.css');
</style>
</head>
<body>
<div class="node" style="background-color:#DDDDFF">
<a name="Backquote-Patterns"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Destructuring-with-pcase-Patterns.html#Destructuring-with-pcase-Patterns">Destructuring with pcase Patterns</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Extending-pcase.html#Extending-pcase">Extending pcase</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Pattern_002dMatching-Conditional.html#Pattern_002dMatching-Conditional">Pattern-Matching Conditional</a>

</div>

<h4 class="subsection">11.4.3 Backquote-Style Patterns</h4>

<p><a name="index-backquote_002dstyle-patterns-730"></a><a name="index-matching_002c-structural-731"></a><a name="index-structural-matching-732"></a>
This subsection describes <dfn>backquote-style patterns</dfn>,
a set of builtin patterns that eases structural matching. 
For background, see <a href="Pattern_002dMatching-Conditional.html#Pattern_002dMatching-Conditional">Pattern-Matching Conditional</a>.

   <p>Backquote-style patterns are a powerful set of <code>pcase</code> pattern
extensions (created using <code>pcase-defmacro</code>) that make it easy to
match <var>expval</var> against specifications of its <em>structure</em>.

   <p>For example, to match <var>expval</var> that must be a list of two
elements whose first element is a specific string and the second
element is any value, you can write a core pattern:

<pre class="example">     (and (pred listp)
          ls
          (guard (= 2 (length ls)))
          (guard (string= "first" (car ls)))
          (let second-elem (cadr ls)))
</pre>
   <p class="noindent">or you can write the equivalent backquote-style pattern:

<pre class="example">     `("first" ,second-elem)
</pre>
   <p class="noindent">The backquote-style pattern is more concise,
resembles the structure of <var>expval</var>,
and avoids binding <code>ls</code>.

   <p>A backquote-style pattern has the form <code>`</code><var>qpat</var> where
<var>qpat</var> can have the following forms:

     <dl>
<dt><code>(</code><var>qpat1</var><code> . </code><var>qpat2</var><code>)</code><dd>Matches if <var>expval</var> is a cons cell whose <code>car</code>
matches <var>qpat1</var> and whose <code>cdr</code> matches <var>qpat2</var>. 
This readily generalizes to lists as in
<code>(</code><var>qpat1</var><code>&nbsp;</code><var>qpat2</var><code>&nbsp;...)</code><!-- /@w -->.

     <br><dt><code>[</code><var>qpat1</var> <var>qpat2</var><code> ... </code><var>qpatm</var><code>]</code><dd>Matches if <var>expval</var> is a vector of length <var>m</var> whose
<code>0</code>..<code>(</code><var>m</var><code>-1)</code>th elements match <var>qpat1</var>,
<var>qpat2</var> <small class="dots">...</small> <var>qpatm</var>, respectively.

     <br><dt><var>symbol</var><dt><var>keyword</var><dt><var>integer</var><dt><var>string</var><dd>Matches if the corresponding element of <var>expval</var> is
<code>equal</code> to the specified literal object. 
Note that, aside from <var>symbol</var>, this is the same set of
self-quoting literal objects that are acceptable as a core pattern.

     <br><dt><code>,</code><var>pattern</var><dd>Matches if the corresponding element of <var>expval</var>
matches <var>pattern</var>. 
Note that <var>pattern</var> is any kind that <code>pcase</code> supports. 
(In the example above, <code>second-elem</code> is a <var>symbol</var>
core pattern; it therefore matches anything,
and let-binds <code>second-elem</code>.) 
</dl>

   <p>The <dfn>corresponding element</dfn> is the portion of <var>expval</var>
that is in the same structural position as the structural position
of <var>qpat</var> in the backquote-style pattern. 
(In the example above, the corresponding element of
<code>second-elem</code> is the second element of <var>expval</var>.)

   <p>Here is an example of using <code>pcase</code> to implement a simple
interpreter for a little expression language
(note that this requires lexical binding for the
lambda expression in the <code>fn</code> clause to properly
capture <code>body</code> and <code>arg</code> (see <a href="Lexical-Binding.html#Lexical-Binding">Lexical Binding</a>):

<pre class="example">     (defun evaluate (form env)
       (pcase form
         (`(add ,x ,y)       (+ (evaluate x env)
                                (evaluate y env)))
         (`(call ,fun ,arg)  (funcall (evaluate fun env)
                                      (evaluate arg env)))
         (`(fn ,arg ,body)   (lambda (val)
                               (evaluate body (cons (cons arg val)
                                                    env))))
         ((pred numberp)     form)
         ((pred symbolp)     (cdr (assq form env)))
         (_                  (error "Syntax error: %S" form))))
</pre>
   <p class="noindent">The first three clauses use backquote-style patterns. 
<code>`(add ,x ,y)</code> is a pattern that checks that <code>form</code>
is a three-element list starting with the literal symbol <code>add</code>,
then extracts the second and third elements and binds them
to symbols <code>x</code> and <code>y</code>, respectively. 
The clause body evaluates <code>x</code> and <code>y</code> and adds the results. 
Similarly, the <code>call</code> clause implements a function call,
and the <code>fn</code> clause implements an anonymous function definition.

   <p>The remaining clauses use core patterns. 
<code>(pred numberp)</code> matches if <code>form</code> is a number. 
On match, the body evaluates it. 
<code>(pred symbolp)</code> matches if <code>form</code> is a symbol. 
On match, the body looks up the symbol in <code>env</code> and
returns its association. 
Finally, <code>_</code> is the catch-all pattern that
matches anything, so it's suitable for reporting syntax errors.

   <p>Here are some sample programs in this small language, including their
evaluation results:

<pre class="example">     (evaluate '(add 1 2) nil)                 &rArr; 3
     (evaluate '(add x y) '((x . 1) (y . 2)))  &rArr; 3
     (evaluate '(call (fn x (add 1 x)) 2) nil) &rArr; 3
     (evaluate '(sub 1 2) nil)                 &rArr; error
</pre>
   </body></html>

