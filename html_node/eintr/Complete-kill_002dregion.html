<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rev="made" href="mailto:bug-gnu-emacs@gnu.org">
<link rel="icon" type="image/png" href="/graphics/gnu-head-mini.png">
<meta name="ICBM" content="42.256233,-71.006581">
<meta name="DC.title" content="gnu.org">

<title>Complete kill-region - Programming in Emacs Lisp</title>
<!--
This is an `Introduction to Programming in Emacs Lisp', for
people who are not programmers.

   Distributed with Emacs version 26.2.

   Copyright (C) 1990--1995, 1997, 2001--2019 Free Software
Foundation, Inc.



   Printed copies available from `https://shop.fsf.org/'. Published by:
     GNU Press,                        https://www.fsf.org/licensing/gnu-press/
     a division of the                 email: sales@fsf.org
     Free Software Foundation, Inc.    Tel: +1 (617) 542-5942
     51 Franklin Street, Fifth Floor   Fax: +1 (617) 542-2652
     Boston, MA 02110-1301 USA

   ISBN 1-882114-43-4

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; there being no Invariant Section, with the Front-Cover
     Texts being ``A GNU Manual'', and with the Back-Cover Texts as in
     (a) below.  A copy of the license is included in the section
     entitled ``GNU Free Documentation License''.

     (a) The FSF's Back-Cover Text is: ``You have the freedom to copy
     and modify this GNU manual.  Buying copies from the FSF supports
     it in developing GNU and promoting software freedom.''
   -->
<style type="text/css">
@import url('/software/emacs/manual.css');
</style>
</head>
<body>
<div class="node" style="background-color:#DDDDFF">
<a name="Complete-kill-region"></a>
<a name="Complete-kill_002dregion"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="condition_002dcase.html#condition_002dcase">condition-case</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="kill_002dregion.html#kill_002dregion">kill-region</a>

</div>

<h4 class="unnumberedsubsec">The Complete <code>kill-region</code> Definition</h4>

   <p>We will go through the <code>condition-case</code> code in a moment.  First,
let us look at the definition of <code>kill-region</code>, with comments
added:

<!-- GNU Emacs 22: -->
<pre class="smallexample">     (defun kill-region (beg end)
       "Kill (\"cut\") text between point and mark.
     This deletes the text from the buffer and saves it in the kill ring.
     The command \\[yank] can retrieve it from there. ... "
     
       ;; &bull; Since order matters, pass point first.
       (interactive (list (point) (mark)))
       ;; &bull; And tell us if we cannot cut the text.
       ;; 'unless' is an 'if' without a then-part.
       (unless (and beg end)
         (error "The mark is not set now, so there is no region"))
     
       ;; &bull; 'condition-case' takes three arguments.
       ;;    If the first argument is nil, as it is here,
       ;;    information about the error signal is not
       ;;    stored for use by another function.
       (condition-case nil
     
           ;; &bull; The second argument to 'condition-case' tells the
           ;;    Lisp interpreter what to do when all goes well.
     
           ;;    It starts with a 'let' function that extracts the string
           ;;    and tests whether it exists.  If so (that is what the
           ;;    'when' checks), it calls an 'if' function that determines
           ;;    whether the previous command was another call to
           ;;    'kill-region'; if it was, then the new text is appended to
           ;;    the previous text; if not, then a different function,
           ;;    'kill-new', is called.
     
           ;;    The 'kill-append' function concatenates the new string and
           ;;    the old.  The 'kill-new' function inserts text into a new
           ;;    item in the kill ring.
     
           ;;    'when' is an 'if' without an else-part.  The second 'when'
           ;;    again checks whether the current string exists; in
           ;;    addition, it checks whether the previous command was
           ;;    another call to 'kill-region'.  If one or the other
           ;;    condition is true, then it sets the current command to
           ;;    be 'kill-region'.
           (let ((string (filter-buffer-substring beg end t)))
             (when string                    ;STRING is nil if BEG = END
               ;; Add that string to the kill ring, one way or another.
               (if (eq last-command 'kill-region)
                   ;;    &minus; 'yank-handler' is an optional argument to
                   ;;    'kill-region' that tells the 'kill-append' and
                   ;;    'kill-new' functions how deal with properties
                   ;;    added to the text, such as 'bold' or 'italics'.
                   (kill-append string (&lt; end beg) yank-handler)
                 (kill-new string nil yank-handler)))
             (when (or string (eq last-command 'kill-region))
               (setq this-command 'kill-region))
             nil)
     
         ;;  &bull; The third argument to 'condition-case' tells the interpreter
         ;;    what to do with an error.
         ;;    The third argument has a conditions part and a body part.
         ;;    If the conditions are met (in this case,
         ;;             if text or buffer are read-only)
         ;;    then the body is executed.
         ;;    The first part of the third argument is the following:
         ((buffer-read-only text-read-only) ;; the if-part
          ;; ...  the then-part
          (copy-region-as-kill beg end)
          ;;    Next, also as part of the then-part, set this-command, so
          ;;    it will be set in an error
          (setq this-command 'kill-region)
          ;;    Finally, in the then-part, send a message if you may copy
          ;;    the text to the kill ring without signaling an error, but
          ;;    don't if you may not.
          (if kill-read-only-ok
              (progn (message "Read only text copied to kill ring") nil)
            (barf-if-buffer-read-only)
            ;; If the buffer isn't read-only, the text is.
            (signal 'text-read-only (list (current-buffer)))))
</pre>
   </body></html>

