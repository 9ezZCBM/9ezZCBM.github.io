<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rev="made" href="mailto:bug-gnu-emacs@gnu.org">
<link rel="icon" type="image/png" href="/graphics/gnu-head-mini.png">
<meta name="ICBM" content="42.256233,-71.006581">
<meta name="DC.title" content="gnu.org">

<title>Design @value{COUNT-WORDS} - Programming in Emacs Lisp</title>
<!--
This is an `Introduction to Programming in Emacs Lisp', for
people who are not programmers.

   Distributed with Emacs version 26.2.

   Copyright (C) 1990--1995, 1997, 2001--2019 Free Software
Foundation, Inc.



   Printed copies available from `https://shop.fsf.org/'. Published by:
     GNU Press,                        https://www.fsf.org/licensing/gnu-press/
     a division of the                 email: sales@fsf.org
     Free Software Foundation, Inc.    Tel: +1 (617) 542-5942
     51 Franklin Street, Fifth Floor   Fax: +1 (617) 542-2652
     Boston, MA 02110-1301 USA

   ISBN 1-882114-43-4

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; there being no Invariant Section, with the Front-Cover
     Texts being ``A GNU Manual'', and with the Back-Cover Texts as in
     (a) below.  A copy of the license is included in the section
     entitled ``GNU Free Documentation License''.

     (a) The FSF's Back-Cover Text is: ``You have the freedom to copy
     and modify this GNU manual.  Buying copies from the FSF supports
     it in developing GNU and promoting software freedom.''
   -->
<style type="text/css">
@import url('/software/emacs/manual.css');
</style>
</head>
<body>
<div class="node" style="background-color:#DDDDFF">
<a name="Design-count-words-example"></a>
<a name="Design-count_002dwords_002dexample"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Whitespace-Bug.html#Whitespace-Bug">Whitespace Bug</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="count_002dwords_002dexample.html#count_002dwords_002dexample">count-words-example</a>

</div>

<h4 class="unnumberedsubsec">Designing <code>count-words-example</code></h4>

   <p>First, we will implement the word count command with a <code>while</code>
loop, then with recursion.  The command will, of course, be
interactive.

   <p>The template for an interactive function definition is, as always:

<pre class="smallexample">     (defun <var>name-of-function</var> (<var>argument-list</var>)
       "<var>documentation</var>..."
       (<var>interactive-expression</var>...)
       <var>body</var>...)
</pre>
   <p>What we need to do is fill in the slots.

   <p>The name of the function should be self-explanatory and similar to the
existing <code>count-lines-region</code> name.  This makes the name easier
to remember.  <code>count-words-region</code> is the obvious choice.  Since
that name is now used for the standard Emacs command to count words, we
will name our implementation <code>count-words-example</code>.

   <p>The function counts words within a region.  This means that the
argument list must contain symbols that are bound to the two
positions, the beginning and end of the region.  These two positions
can be called &lsquo;<samp><span class="samp">beginning</span></samp>&rsquo; and &lsquo;<samp><span class="samp">end</span></samp>&rsquo; respectively.  The first
line of the documentation should be a single sentence, since that is
all that is printed as documentation by a command such as
<code>apropos</code>.  The interactive expression will be of the form
&lsquo;<samp><span class="samp">(interactive "r")</span></samp>&rsquo;, since that will cause Emacs to pass the
beginning and end of the region to the function's argument list.  All
this is routine.

   <p>The body of the function needs to be written to do three tasks:
first, to set up conditions under which the <code>while</code> loop can
count words, second, to run the <code>while</code> loop, and third, to send
a message to the user.

   <p>When a user calls <code>count-words-example</code>, point may be at the
beginning or the end of the region.  However, the counting process
must start at the beginning of the region.  This means we will want
to put point there if it is not already there.  Executing
<code>(goto-char beginning)</code> ensures this.  Of course, we will want to
return point to its expected position when the function finishes its
work.  For this reason, the body must be enclosed in a
<code>save-excursion</code> expression.

   <p>The central part of the body of the function consists of a
<code>while</code> loop in which one expression jumps point forward word by
word, and another expression counts those jumps.  The true-or-false-test
of the <code>while</code> loop should test true so long as point should jump
forward, and false when point is at the end of the region.

   <p>We could use <code>(forward-word 1)</code> as the expression for moving point
forward word by word, but it is easier to see what Emacs identifies as a
&ldquo;word&rdquo; if we use a regular expression search.

   <p>A regular expression search that finds the pattern for which it is
searching leaves point after the last character matched.  This means
that a succession of successful word searches will move point forward
word by word.

   <p>As a practical matter, we want the regular expression search to jump
over whitespace and punctuation between words as well as over the
words themselves.  A regexp that refuses to jump over interword
whitespace would never jump more than one word!  This means that
the regexp should include the whitespace and punctuation that follows
a word, if any, as well as the word itself.  (A word may end a buffer
and not have any following whitespace or punctuation, so that part of
the regexp must be optional.)

   <p>Thus, what we want for the regexp is a pattern defining one or more
word constituent characters followed, optionally, by one or more
characters that are not word constituents.  The regular expression for
this is:

<pre class="smallexample">     \w+\W*
</pre>
   <p class="noindent">The buffer's syntax table determines which characters are and are not
word constituents.  For more information about syntax,
see <a href="../elisp/Syntax-Tables.html#Syntax-Tables">Syntax Tables</a>.

   <p>The search expression looks like this:

<pre class="smallexample">     (re-search-forward "\\w+\\W*")
</pre>
   <p class="noindent">(Note that paired backslashes precede the &lsquo;<samp><span class="samp">w</span></samp>&rsquo; and &lsquo;<samp><span class="samp">W</span></samp>&rsquo;.  A
single backslash has special meaning to the Emacs Lisp interpreter. 
It indicates that the following character is interpreted differently
than usual.  For example, the two characters, &lsquo;<samp><span class="samp">\n</span></samp>&rsquo;, stand for
&lsquo;<samp><span class="samp">newline</span></samp>&rsquo;, rather than for a backslash followed by &lsquo;<samp><span class="samp">n</span></samp>&rsquo;.  Two
backslashes in a row stand for an ordinary, unspecial backslash, so
Emacs Lisp interpreter ends of seeing a single backslash followed by a
letter.  So it discovers the letter is special.)

   <p>We need a counter to count how many words there are; this variable
must first be set to 0 and then incremented each time Emacs goes
around the <code>while</code> loop.  The incrementing expression is simply:

<pre class="smallexample">     (setq count (1+ count))
</pre>
   <p>Finally, we want to tell the user how many words there are in the
region.  The <code>message</code> function is intended for presenting this
kind of information to the user.  The message has to be phrased so
that it reads properly regardless of how many words there are in the
region: we don't want to say that &ldquo;there are 1 words in the region&rdquo;. 
The conflict between singular and plural is ungrammatical.  We can
solve this problem by using a conditional expression that evaluates
different messages depending on the number of words in the region. 
There are three possibilities: no words in the region, one word in the
region, and more than one word.  This means that the <code>cond</code>
special form is appropriate.

   <p>All this leads to the following function definition:

<pre class="smallexample">     ;;; <span class="roman">First version; has bugs!</span>
     (defun count-words-example (beginning end)
       "Print number of words in the region.
     Words are defined as at least one word-constituent
     character followed by at least one character that
     is not a word-constituent.  The buffer's syntax
     table determines which characters these are."
       (interactive "r")
       (message "Counting words in region ... ")
     
     ;;; <span class="roman">1. Set up appropriate conditions.</span>
       (save-excursion
         (goto-char beginning)
         (let ((count 0))
     
     ;;; <span class="roman">2. Run the</span> while <span class="roman">loop.</span>
           (while (&lt; (point) end)
             (re-search-forward "\\w+\\W*")
             (setq count (1+ count)))
     
     ;;; <span class="roman">3. Send a message to the user.</span>
           (cond ((zerop count)
                  (message
                   "The region does NOT have any words."))
                 ((= 1 count)
                  (message
                   "The region has 1 word."))
                 (t
                  (message
                   "The region has %d words." count))))))
</pre>
   <p class="noindent">As written, the function works, but not in all circumstances.

   </body></html>

