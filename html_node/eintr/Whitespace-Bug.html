<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rev="made" href="mailto:bug-gnu-emacs@gnu.org">
<link rel="icon" type="image/png" href="/graphics/gnu-head-mini.png">
<meta name="ICBM" content="42.256233,-71.006581">
<meta name="DC.title" content="gnu.org">

<title>Whitespace Bug - Programming in Emacs Lisp</title>
<!--
This is an `Introduction to Programming in Emacs Lisp', for
people who are not programmers.

   Distributed with Emacs version 26.2.

   Copyright (C) 1990--1995, 1997, 2001--2019 Free Software
Foundation, Inc.



   Printed copies available from `https://shop.fsf.org/'. Published by:
     GNU Press,                        https://www.fsf.org/licensing/gnu-press/
     a division of the                 email: sales@fsf.org
     Free Software Foundation, Inc.    Tel: +1 (617) 542-5942
     51 Franklin Street, Fifth Floor   Fax: +1 (617) 542-2652
     Boston, MA 02110-1301 USA

   ISBN 1-882114-43-4

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; there being no Invariant Section, with the Front-Cover
     Texts being ``A GNU Manual'', and with the Back-Cover Texts as in
     (a) below.  A copy of the license is included in the section
     entitled ``GNU Free Documentation License''.

     (a) The FSF's Back-Cover Text is: ``You have the freedom to copy
     and modify this GNU manual.  Buying copies from the FSF supports
     it in developing GNU and promoting software freedom.''
   -->
<style type="text/css">
@import url('/software/emacs/manual.css');
</style>
</head>
<body>
<div class="node" style="background-color:#DDDDFF">
<a name="Whitespace-Bug"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="Design-count_002dwords_002dexample.html#Design-count_002dwords_002dexample">Design count-words-example</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="count_002dwords_002dexample.html#count_002dwords_002dexample">count-words-example</a>

</div>

<h4 class="subsection">13.1.1 The Whitespace Bug in <code>count-words-example</code></h4>

<p>The <code>count-words-example</code> command described in the preceding
section has two bugs, or rather, one bug with two manifestations. 
First, if you mark a region containing only whitespace in the middle
of some text, the <code>count-words-example</code> command tells you that the
region contains one word!  Second, if you mark a region containing
only whitespace at the end of the buffer or the accessible portion of
a narrowed buffer, the command displays an error message that looks
like this:

<pre class="smallexample">     Search failed: "\\w+\\W*"
</pre>
   <p>If you are reading this in Info in GNU Emacs, you can test for these
bugs yourself.

   <p>First, evaluate the function in the usual manner to install it.

   <p>If you wish, you can also install this keybinding by evaluating it:

<pre class="smallexample">     (global-set-key "\C-c=" 'count-words-example)
</pre>
   <p>To conduct the first test, set mark and point to the beginning and end
of the following line and then type <kbd>C-c =</kbd> (or <kbd>M-x
count-words-example</kbd> if you have not bound <kbd>C-c =</kbd>):

<pre class="smallexample">         one   two  three
</pre>
   <p class="noindent">Emacs will tell you, correctly, that the region has three words.

   <p>Repeat the test, but place mark at the beginning of the line and place
point just <em>before</em> the word &lsquo;<samp><span class="samp">one</span></samp>&rsquo;.  Again type the command
<kbd>C-c =</kbd> (or <kbd>M-x count-words-example</kbd>).  Emacs should tell you
that the region has no words, since it is composed only of the
whitespace at the beginning of the line.  But instead Emacs tells you
that the region has one word!

   <p>For the third test, copy the sample line to the end of the
<samp><span class="file">*scratch*</span></samp> buffer and then type several spaces at the end of the
line.  Place mark right after the word &lsquo;<samp><span class="samp">three</span></samp>&rsquo; and point at the
end of line.  (The end of the line will be the end of the buffer.) 
Type <kbd>C-c =</kbd> (or <kbd>M-x count-words-example</kbd>) as you did before. 
Again, Emacs should tell you that the region has no words, since it is
composed only of the whitespace at the end of the line.  Instead,
Emacs displays an error message saying &lsquo;<samp><span class="samp">Search failed</span></samp>&rsquo;.

   <p>The two bugs stem from the same problem.

   <p>Consider the first manifestation of the bug, in which the command
tells you that the whitespace at the beginning of the line contains
one word.  What happens is this: The <code>M-x count-words-example</code>
command moves point to the beginning of the region.  The <code>while</code>
tests whether the value of point is smaller than the value of
<code>end</code>, which it is.  Consequently, the regular expression search
looks for and finds the first word.  It leaves point after the word. 
<code>count</code> is set to one.  The <code>while</code> loop repeats; but this
time the value of point is larger than the value of <code>end</code>, the
loop is exited; and the function displays a message saying the number
of words in the region is one.  In brief, the regular expression
search looks for and finds the word even though it is outside
the marked region.

   <p>In the second manifestation of the bug, the region is whitespace at
the end of the buffer.  Emacs says &lsquo;<samp><span class="samp">Search failed</span></samp>&rsquo;.  What happens
is that the true-or-false-test in the <code>while</code> loop tests true, so
the search expression is executed.  But since there are no more words
in the buffer, the search fails.

   <p>In both manifestations of the bug, the search extends or attempts to
extend outside of the region.

   <p>The solution is to limit the search to the region&mdash;this is a fairly
simple action, but as you may have come to expect, it is not quite as
simple as you might think.

   <p>As we have seen, the <code>re-search-forward</code> function takes a search
pattern as its first argument.  But in addition to this first,
mandatory argument, it accepts three optional arguments.  The optional
second argument bounds the search.  The optional third argument, if
<code>t</code>, causes the function to return <code>nil</code> rather than signal
an error if the search fails.  The optional fourth argument is a
repeat count.  (In Emacs, you can see a function's documentation by
typing <kbd>C-h f</kbd>, the name of the function, and then &lt;RET&gt;.)

   <p>In the <code>count-words-example</code> definition, the value of the end of
the region is held by the variable <code>end</code> which is passed as an
argument to the function.  Thus, we can add <code>end</code> as an argument
to the regular expression search expression:

<pre class="smallexample">     (re-search-forward "\\w+\\W*" end)
</pre>
   <p>However, if you make only this change to the <code>count-words-example</code>
definition and then test the new version of the definition on a
stretch of whitespace, you will receive an error message saying
&lsquo;<samp><span class="samp">Search failed</span></samp>&rsquo;.

   <p>What happens is this: the search is limited to the region, and fails
as you expect because there are no word-constituent characters in the
region.  Since it fails, we receive an error message.  But we do not
want to receive an error message in this case; we want to receive the
message &ldquo;The region does NOT have any words.&rdquo;

   <p>The solution to this problem is to provide <code>re-search-forward</code>
with a third argument of <code>t</code>, which causes the function to return
<code>nil</code> rather than signal an error if the search fails.

   <p>However, if you make this change and try it, you will see the message
&ldquo;Counting words in region ... &rdquo; and <small class="dots">...</small> you will keep on seeing
that message <small class="dots">...</small>, until you type <kbd>C-g</kbd> (<code>keyboard-quit</code>).

   <p>Here is what happens: the search is limited to the region, as before,
and it fails because there are no word-constituent characters in the
region, as expected.  Consequently, the <code>re-search-forward</code>
expression returns <code>nil</code>.  It does nothing else.  In particular,
it does not move point, which it does as a side effect if it finds the
search target.  After the <code>re-search-forward</code> expression returns
<code>nil</code>, the next expression in the <code>while</code> loop is evaluated. 
This expression increments the count.  Then the loop repeats.  The
true-or-false-test tests true because the value of point is still less
than the value of end, since the <code>re-search-forward</code> expression
did not move point. <small class="dots">...</small> and the cycle repeats <small class="dots">...</small>

   <p>The <code>count-words-example</code> definition requires yet another
modification, to cause the true-or-false-test of the <code>while</code> loop
to test false if the search fails.  Put another way, there are two
conditions that must be satisfied in the true-or-false-test before the
word count variable is incremented: point must still be within the
region and the search expression must have found a word to count.

   <p>Since both the first condition and the second condition must be true
together, the two expressions, the region test and the search
expression, can be joined with an <code>and</code> special form and embedded in
the <code>while</code> loop as the true-or-false-test, like this:

<pre class="smallexample">     (and (&lt; (point) end) (re-search-forward "\\w+\\W*" end t))
</pre>
   <!-- colon in printed section title causes problem in Info cross reference -->
<!-- also trouble with an overfull hbox -->
   <p>The <code>re-search-forward</code> expression returns <code>t</code> if the search
succeeds and as a side effect moves point.  Consequently, as words are
found, point is moved through the region.  When the search expression
fails to find another word, or when point reaches the end of the
region, the true-or-false-test tests false, the <code>while</code> loop
exits, and the <code>count-words-example</code> function displays one or
other of its messages.

   <p>After incorporating these final changes, the <code>count-words-example</code>
works without bugs (or at least, without bugs that I have found!). 
Here is what it looks like:

<pre class="smallexample">     ;;; <span class="roman">Final version:</span> <code>while</code>
     (defun count-words-example (beginning end)
       "Print number of words in the region."
       (interactive "r")
       (message "Counting words in region ... ")
     
     ;;; <span class="roman">1. Set up appropriate conditions.</span>
       (save-excursion
         (let ((count 0))
           (goto-char beginning)
     
     ;;; <span class="roman">2. Run the</span> while <span class="roman">loop.</span>
           (while (and (&lt; (point) end)
                       (re-search-forward "\\w+\\W*" end t))
             (setq count (1+ count)))
     
     ;;; <span class="roman">3. Send a message to the user.</span>
           (cond ((zerop count)
                  (message
                   "The region does NOT have any words."))
                 ((= 1 count)
                  (message
                   "The region has 1 word."))
                 (t
                  (message
                   "The region has %d words." count))))))
</pre>
   </body></html>

