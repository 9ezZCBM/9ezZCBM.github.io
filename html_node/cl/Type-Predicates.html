<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rev="made" href="mailto:bug-gnu-emacs@gnu.org">
<link rel="icon" type="image/png" href="/graphics/gnu-head-mini.png">
<meta name="ICBM" content="42.256233,-71.006581">
<meta name="DC.title" content="gnu.org">

<title>Type Predicates - Common Lisp Extensions</title>
<!--
This file documents the GNU Emacs Common Lisp emulation package.

Copyright (C) 1993, 2001--2019 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being ``A GNU Manual'', and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     ``GNU Free Documentation License''.

     (a) The FSF's Back-Cover Text is: ``You have the freedom to copy
     and modify this GNU manual.''
   -->
<style type="text/css">
@import url('/software/emacs/manual.css');
</style>
</head>
<body>
<div class="node" style="background-color:#DDDDFF">
<a name="Type-Predicates"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Equality-Predicates.html#Equality-Predicates">Equality Predicates</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Predicates.html#Predicates">Predicates</a>

</div>

<h3 class="section">3.1 Type Predicates</h3>

<div class="defun">
&mdash; Function: <b>cl-typep</b><var> object type<a name="index-cl_002dtypep-12"></a></var><br>
<blockquote><p>Check if <var>object</var> is of type <var>type</var>, where <var>type</var> is a
(quoted) type name of the sort used by Common Lisp.  For example,
<code>(cl-typep foo 'integer)</code> is equivalent to <code>(integerp foo)</code>. 
</p></blockquote></div>

   <p>The <var>type</var> argument to the above function is either a symbol
or a list beginning with a symbol.

     <ul>
<li>If the type name is a symbol, Emacs appends &lsquo;<samp><span class="samp">-p</span></samp>&rsquo; to the
symbol name to form the name of a predicate function for testing
the type.  (Built-in predicates whose names end in &lsquo;<samp><span class="samp">p</span></samp>&rsquo; rather
than &lsquo;<samp><span class="samp">-p</span></samp>&rsquo; are used when appropriate.)

     <li>The type symbol <code>t</code> stands for the union of all types. 
<code>(cl-typep </code><var>object</var><code> t)</code> is always true.  Likewise, the
type symbol <code>nil</code> stands for nothing at all, and
<code>(cl-typep </code><var>object</var><code> nil)</code> is always false.

     <li>The type symbol <code>null</code> represents the symbol <code>nil</code>. 
Thus <code>(cl-typep </code><var>object</var><code> 'null)</code> is equivalent to
<code>(null </code><var>object</var><code>)</code>.

     <li>The type symbol <code>atom</code> represents all objects that are not cons
cells. Thus <code>(cl-typep </code><var>object</var><code> 'atom)</code> is equivalent to
<code>(atom </code><var>object</var><code>)</code>.

     <li>The type symbol <code>real</code> is a synonym for <code>number</code>, and
<code>fixnum</code> is a synonym for <code>integer</code>.

     <li>The type symbols <code>character</code> and <code>string-char</code> match
integers in the range from 0 to 255.

     <li>The type list <code>(integer </code><var>low</var> <var>high</var><code>)</code> represents all
integers between <var>low</var> and <var>high</var>, inclusive.  Either bound
may be a list of a single integer to specify an exclusive limit,
or a <code>*</code> to specify no limit.  The type <code>(integer * *)</code>
is thus equivalent to <code>integer</code>.

     <li>Likewise, lists beginning with <code>float</code>, <code>real</code>, or
<code>number</code> represent numbers of that type falling in a particular
range.

     <li>Lists beginning with <code>and</code>, <code>or</code>, and <code>not</code> form
combinations of types.  For example, <code>(or integer (float 0 *))</code>
represents all objects that are integers or non-negative floats.

     <li>Lists beginning with <code>member</code> or <code>cl-member</code> represent
objects <code>eql</code> to any of the following values.  For example,
<code>(member 1 2 3 4)</code> is equivalent to <code>(integer 1 4)</code>,
and <code>(member nil)</code> is equivalent to <code>null</code>.

     <li>Lists of the form <code>(satisfies </code><var>predicate</var><code>)</code> represent
all objects for which <var>predicate</var> returns true when called
with that object as an argument. 
</ul>

   <p>The following function and macro (not technically predicates) are
related to <code>cl-typep</code>.

<div class="defun">
&mdash; Function: <b>cl-coerce</b><var> object type<a name="index-cl_002dcoerce-13"></a></var><br>
<blockquote><p>This function attempts to convert <var>object</var> to the specified
<var>type</var>.  If <var>object</var> is already of that type as determined by
<code>cl-typep</code>, it is simply returned.  Otherwise, certain types of
conversions will be made:  If <var>type</var> is any sequence type
(<code>string</code>, <code>list</code>, etc.) then <var>object</var> will be
converted to that type if possible.  If <var>type</var> is
<code>character</code>, then strings of length one and symbols with
one-character names can be coerced.  If <var>type</var> is <code>float</code>,
then integers can be coerced in versions of Emacs that support
floats.  In all other circumstances, <code>cl-coerce</code> signals an
error. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>cl-deftype</b><var> name arglist forms<small class="dots">...</small><a name="index-cl_002ddeftype-14"></a></var><br>
<blockquote><p>This macro defines a new type called <var>name</var>.  It is similar
to <code>defmacro</code> in many ways; when <var>name</var> is encountered
as a type name, the body <var>forms</var> are evaluated and should
return a type specifier that is equivalent to the type.  The
<var>arglist</var> is a Common Lisp argument list of the sort accepted
by <code>cl-defmacro</code>.  The type specifier &lsquo;<samp><span class="samp">(</span><var>name</var> <var>args</var><span class="samp">...)</span></samp>&rsquo;
is expanded by calling the expander with those arguments; the type
symbol &lsquo;<samp><var>name</var></samp>&rsquo; is expanded by calling the expander with
no arguments.  The <var>arglist</var> is processed the same as for
<code>cl-defmacro</code> except that optional arguments without explicit
defaults use <code>*</code> instead of <code>nil</code> as the &ldquo;default&rdquo;
default.  Some examples:

     <pre class="example">          (cl-deftype null () '(satisfies null))    ; predefined
          (cl-deftype list () '(or null cons))      ; predefined
          (cl-deftype unsigned-byte (&amp;optional bits)
            (list 'integer 0 (if (eq bits '*) bits (1- (lsh 1 bits)))))
          (unsigned-byte 8)  ==  (integer 0 255)
          (unsigned-byte)  ==  (integer 0 *)
          unsigned-byte  ==  (integer 0 *)
</pre>
        <p class="noindent">The last example shows how the Common Lisp <code>unsigned-byte</code>
type specifier could be implemented if desired; this package does
not implement <code>unsigned-byte</code> by default. 
</p></blockquote></div>

   <p>The <code>cl-typecase</code> (see <a href="Conditionals.html#Conditionals">Conditionals</a>) and <code>cl-check-type</code>
(see <a href="Assertions.html#Assertions">Assertions</a>) macros also use type names.  The <code>cl-map</code>,
<code>cl-concatenate</code>, and <code>cl-merge</code> functions take type-name
arguments to specify the type of sequence to return.  See <a href="Sequences.html#Sequences">Sequences</a>.

   </body></html>

